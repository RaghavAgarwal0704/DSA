1. LEVEL ORDER TRAVERSAL

vector<int> levelOrder(Node * node){
    if(node==nullptr)return vector<int>();
    queue<Node*>q;
    vector<int>vec;
    q.push(node);
    while(!q.empty()){
        if(q.front()->left!=nullptr)q.push(q.front()->left);
        if(q.front()->right!=nullptr)q.push(q.front()->right);
        vec.push_back(q.front()->data);
        q.pop();
    }
    return vec;
}

---------------------------------------------------------------
2. REVERSE LEVEL ORDER TRAVERSAL

vector<int> reverseLevelOrder(Node *root)
{
    queue<Node*>q;
    vector<int>vec;
    stack<int>s;
    q.push(root);
    while(!q.empty()){
        if(q.front()->right!=nullptr)q.push(q.front()->right);
        if(q.front()->left!=nullptr)q.push(q.front()->left);
        s.push(q.front()->data);
        q.pop();
    }
    while(!s.empty()){
        vec.push_back(s.top());
        s.pop();
    }
    return vec;
}

---------------------------------------------------------------
3. HEIGHT OF A TREE

int height(struct Node* node){
        return node?1+max(height(node->left),height(node->right)):0;
}

---------------------------------------------------------------
4. DIAMETER OF A TREE

int diameterUtil(Node* root, int& h) {
    if (!root) {
        h = 0;
        return 0;
    }
    int lh = 0, rh = 0;
    int ld = diameterUtil(root->left, lh);
    int rd = diameterUtil(root->right, rh);
    h = max(lh, rh) + 1;
    return max(rh + lh + 1, max(ld, rd));
}

int diameter(Node* root) {
    if (!root) return 0;
    /* 
        NaÃ¯ve approach : need to calculate height for every node seperately;
        return max(height(root->left) + height(root->right) + 1, max(diameter(root->left), diameter(root->right)));
    */
    //Optimized soln
    int h = 0;
    return diameterUtil(root, h);
}

---------------------------------------------------------------
5. MIRROR OF A TREE

void mirror(Node *root) {
    if (root == NULL)
        return;
    mirror(root->left);
    mirror(root->right);
    Node *temp = root->left;
    root->left = root->right;
    root->right = temp;
}

---------------------------------------------------------------
6A. INORDER TRAVERSAL(ITERATIVE) (Using stack)

void inOrder(Node *root) {
    stack <Node*> st;
    Node* node=root;

    while (node || !st.empty()) {
        if (node)
            st.push(node), node = node->left;
        else {
            node = st.top();
            cout << node->data << " ";
            st.pop();
            node = node->right;
        }
    }
}

6B. INORDER TRAVERSAL(ITERATIVE) (Without using stack-Morris traversal)

---------------------------------------------------------------
7. INORDER TRAVERSAL (RECURSIVE)

void inOrder(Node* root){
    inOrder(root->left);
    cout<<root->data<<" ";
    inOrder(root->right);
}

---------------------------------------------------------------
8. PREORDER TRAVERSAL(ITERATIVE)


void preOrder(Node *root) {
    stack<Node *> st;
    st.push(root);
    while (!st.empty()) {
        Node *node = st.top();
        st.pop();
        cout << node->data << " ";
        if (node->right) st.push(node->right);
        if (node->left) st.push(node->left);
    }
}

---------------------------------------------------------------
9. PREORDER TRAVERSAL(RECURSIVE)

void preOrder(Node* root){
    cout<<root->data<<" ";
    preOrder(root->left);
    preOrder(root->right);
}


---------------------------------------------------------------
10. POSTORDER TRAVERSAL (ITERATIVE)

void postOrder(Node *root) {
    stack<Node *> st;
    st.push(root);
    vector<int> ans;
    while (!st.empty()) {
        Node *node = st.top();
        ans.push_back(node->data);
        st.pop();
        if (node->left) st.push(node->left);
        if (node->right) st.push(node->right);
    }
    for (auto i = ans.rbegin(); i != ans.rend(); i++) cout << *i << " ";
}

---------------------------------------------------------------
11. POSTORDER TRAVERSAL (RECURSIVE)

void postOrder(Node* root){
    postOrder(root->left);
    postOrder(root->right);
    cout<<root->data<<" ";
}

---------------------------------------------------------------
12. LEFT VIEW OF TREE

vector<int> leftView(Node *root)
{
   vector<int>vec;
   queue<Node*>q;
   q.push(root);
   if(!root)return vec;
   while(!q.empty()){
       int size=q.size();
       vec.push_back(q.front()->data);
       while(size--){
           Node *temp=q.front();
           if(temp->left)q.push(temp->left);
           if(temp->right)q.push(temp->right);
           q.pop();
       }
   }
   return vec;
}

---------------------------------------------------------------
13. RIGHT VIEW OF TREE

vector<int> leftView(Node *root)
{
   vector<int>vec;
   queue<Node*>q;
   q.push(root);
   if(!root)return vec;
   while(!q.empty()){
       int size=q.size();
       vec.push_back(q.front()->data);
       while(size--){
           Node *temp=q.front();
           if(temp->right)q.push(temp->right);
           if(temp->left)q.push(temp->left);
           q.pop();
       }
   }
   return vec;
}

---------------------------------------------------------------
14. TOP VIEW OF TREE

---------------------------------------------------------------
15. BOTTOM VIEW OF TREE

void utilBottomView(Node* root, int ht, int hz, map<int, pair<int, int>>& m) {
    if (!root) return;
    if (m.find(hz) == m.end())
        m[hz] = pair<int, int>(root->data, ht);
    else if (m[hz].second <= ht)
        m[hz] = pair<int, int>(root->data, ht);
    utilBottomView(root->left, ht + 1, hz - 1, m);
    utilBottomView(root->right, ht + 1, hz + 1, m);
}
vector<int> bottomView(Node* root) {
    //map => [horizontal dist](key) : {root->val, height}(value)
    map<int, pair<int, int>> m;
    utilBottomView(root, 0, 0, m);
    vector<int> ans;
    for (auto p : m) ans.push_back((p.second).first);
    return ans;
}

---------------------------------------------------------------
16. Zigzag traversal

vector<int> zigzag(Node* root) {
    vector<int> ans;
    if (!root) return ans;
    queue<Node*> q;
    q.push(root);
    int chance = 0;
    while (!q.empty()) {
        int n = q.size();
        vector<int> v;
        while (n--) {
            Node* temp = q.front();
            q.pop();
            if (temp->left) q.push(temp->left);
            if (temp->right) q.push(temp->right);
            v.push_back(temp->data);
        }
        chance++ & 1 ? ans.insert(ans.end(), v.begin(), v.end()) : ans.insert(ans.end(), v.rbegin(), v.rend());
    }
    return ans;
}

---------------------------------------------------------------
17. Check if tree is balanced

bool utilBalanced(Node* root, int& ht) {
    if (!root) return true;
    int lh = 0;
    bool lb = util(root->left, lh);
    int rh = 0;
    bool rb = util(root->right, rh);
    ht = max(lh + 1, rh + 1);
    return lb && rb && abs(lh - rh) <= 1;
}
bool isBalanced(Node* root) {
    int ht = 0;
    return util(root, ht);
}

---------------------------------------------------------------
18. diagonal traversal 
---------------------------------------------------------------
19. Vertical traversal
---------------------------------------------------------------
20. Boundary traversal
---------------------------------------------------------------
