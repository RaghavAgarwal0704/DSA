1. LEVEL ORDER TRAVERSAL

vector<int> levelOrder(Node * node){
    if(node==nullptr)return vector<int>();
    queue<Node*>q;
    vector<int>vec;
    q.push(node);
    while(!q.empty()){
        if(q.front()->left!=nullptr)q.push(q.front()->left);
        if(q.front()->right!=nullptr)q.push(q.front()->right);
        vec.push_back(q.front()->data);
        q.pop();
    }
    return vec;
}

---------------------------------------------------------------
2. REVERSE LEVEL ORDER TRAVERSAL

vector<int> reverseLevelOrder(Node *root)
{
    queue<Node*>q;
    vector<int>vec;
    stack<int>s;
    q.push(root);
    while(!q.empty()){
        if(q.front()->right!=nullptr)q.push(q.front()->right);
        if(q.front()->left!=nullptr)q.push(q.front()->left);
        s.push(q.front()->data);
        q.pop();
    }
    while(!s.empty()){
        vec.push_back(s.top());
        s.pop();
    }
    return vec;
}

---------------------------------------------------------------
3. HEIGHT OF A TREE

int height(struct Node* node){
        return node?1+max(height(node->left),height(node->right)):0;
}

---------------------------------------------------------------
4. DIAMETER OF A TREE

int diameterUtil(Node* root, int& h) {
    if (!root) {
        h = 0;
        return 0;
    }
    int lh = 0, rh = 0;
    int ld = diameterUtil(root->left, lh);
    int rd = diameterUtil(root->right, rh);
    h = max(lh, rh) + 1;
    return max(rh + lh + 1, max(ld, rd));
}

int diameter(Node* root) {
    if (!root) return 0;
    /* 
        NaÃ¯ve approach : need to calculate height for every node seperately;
        return max(height(root->left) + height(root->right) + 1, max(diameter(root->left), diameter(root->right)));
    */
    //Optimized soln
    int h = 0;
    return diameterUtil(root, h);
}

---------------------------------------------------------------
5. MIRROR OF A TREE

---------------------------------------------------------------
6. INORDER TRAVERSAL(ITERATIVE)

void inOrder(Node *root) {
    stack<Node *> st;
    st.push(root);
    Node *node = st.top();

    while (node || !st.empty()) {
        if (node)
            st.push(node), node = node->left;
        else {
            node = st.top();
            cout << node->data << " ";
            st.pop();
            node = node->right;
        }
    }
}

---------------------------------------------------------------
7. INORDER TRAVERSAL (RECURSIVE)

---------------------------------------------------------------
8. PREORDER TRAVERSAL(ITERATIVE)


void preOrder(Node *root) {
    stack<Node *> st;
    st.push(root);
    while (!st.empty()) {
        Node *node = st.top();
        st.pop();
        cout << node->data << " ";
        if (node->right) st.push(node->right);
        if (node->left) st.push(node->left);
    }
}

---------------------------------------------------------------
9. PREORDER TRAVERSAL(RECURSIVE)

---------------------------------------------------------------
10. POSTORDER TRAVERSAL (ITERATIVE)

---------------------------------------------------------------
11. POSTORDER TRAVERSAL (RECURSIVE)

---------------------------------------------------------------
12. LEFT VIEW OF TREE

vector<int> leftView(Node *root)
{
   vector<int>vec;
   queue<Node*>q;
   q.push(root);
   if(!root)return vec;
   while(!q.empty()){
       int size=q.size();
       vec.push_back(q.front()->data);
       while(size--){
           Node *temp=q.front();
           if(temp->left)q.push(temp->left);
           if(temp->right)q.push(temp->right);
           q.pop();
       }
   }
   return vec;
}

---------------------------------------------------------------
13. RIGHT VIEW OF TREE

vector<int> leftView(Node *root)
{
   vector<int>vec;
   queue<Node*>q;
   q.push(root);
   if(!root)return vec;
   while(!q.empty()){
       int size=q.size();
       vec.push_back(q.front()->data);
       while(size--){
           Node *temp=q.front();
           if(temp->right)q.push(temp->right);
           if(temp->left)q.push(temp->left);
           q.pop();
       }
   }
   return vec;
}

---------------------------------------------------------------
14. TOP VIEW OF TREE
---------------------------------------------------------------
15. BOTTOM VIEW OF TREE
---------------------------------------------------------------
